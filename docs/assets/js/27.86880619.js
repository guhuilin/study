(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{196:function(e,a,t){"use strict";t.r(a);var r=t(0),v=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),t("p",[e._v("很多人面试会问啥 vue 实现原理，但我觉得这略过分，有多少人会老老实实看过它的源码。但我觉得面者这也只是知道 vue 双向绑定的原理吧。")]),e._v(" "),t("ul",[t("li",[e._v("发布者-订阅者模式（backbone.js）")])]),e._v(" "),t("p",[e._v("一般通过 sub, pub 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这种方式现在毕竟太 low 了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式")]),e._v(" "),t("ul",[t("li",[e._v("脏值检查（angular.js）\nangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下：")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("DOM 事件，譬如用户输入文本，点击按钮等( ng-click )")]),e._v(" "),t("li",[e._v("XHR 响应事件 ( $http )")]),e._v(" "),t("li",[e._v("浏览器 Location 变更事件 ( $location )")]),e._v(" "),t("li",[e._v("Timer 事件( $timeout , $interval )")]),e._v(" "),t("li",[e._v("执行 $digest() 或 $apply()")])])]),e._v(" "),t("ul",[t("li",[e._v("数据劫持（vue.js）")])]),e._v(" "),t("p",[e._v("vue.js[2.0] 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\nvue.js[3.0]采取了 proxy 的方式")]),e._v(" "),t("h2",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("ul",[t("li",[e._v("是异步编程的一种解决方案")]),e._v(" "),t("li",[e._v("是一个对象")])]),e._v(" "),t("p",[t("strong",[e._v("缺点")])]),e._v(" "),t("ol",[t("li",[e._v("无法取消")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.all()  会包装多个实例成为一个新的promise实例\n\nnew Promise((resolve.reject) =>{\n    // do some async function\n    if(true){\n        // resolve 代表成功的回调\n        resolve(data);\n    }else{\n        // reject 代表失败的回调\n        reject(data);\n    }\n})\n")])])]),t("h4",{attrs:{id:"_3、异步加载图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、异步加载图片","aria-hidden":"true"}},[e._v("#")]),e._v(" 3、异步加载图片")]),e._v(" "),t("ol",[t("li",[e._v("数据请求 -> 接口(Interface)")]),e._v(" "),t("li",[e._v("创建图片")]),e._v(" "),t("li",[e._v("插入到页面当中")])]),e._v(" "),t("h4",{attrs:{id:"_4、继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、继承","aria-hidden":"true"}},[e._v("#")]),e._v(" 4、继承")]),e._v(" "),t("p",[e._v("obj1 extends obj2")]),e._v(" "),t("p",[e._v("如果继承就一定要在contructor第一行加super()方法")]),e._v(" "),t("h4",{attrs:{id:"_5、异步加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、异步加载","aria-hidden":"true"}},[e._v("#")]),e._v(" 5、异步加载")]),e._v(" "),t("ol",[t("li",[e._v("ajax")]),e._v(" "),t("li",[e._v("加载图片")]),e._v(" "),t("li",[e._v("jsonp")])]),e._v(" "),t("h4",{attrs:{id:"_6、语法糖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、语法糖","aria-hidden":"true"}},[e._v("#")]),e._v(" 6、语法糖")]),e._v(" "),t("p",[e._v("再不改变代码的情况下让代码更简洁")]),e._v(" "),t("h4",{attrs:{id:"_7、async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、async","aria-hidden":"true"}},[e._v("#")]),e._v(" 7、async")]),e._v(" "),t("ol",[t("li",[e._v("内置执行器")]),e._v(" "),t("li",[e._v("更好的语义")]),e._v(" "),t("li",[e._v("更广的适用性")]),e._v(" "),t("li",[e._v("返回Promise")])]),e._v(" "),t("h2",{attrs:{id:"vuex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex")])])}],!1,null,null,null);a.default=v.exports}}]);